# 5. Заданы три числа, которые обозначают число, месяц, год (запрашиваем у пользователя). 
# Найти порядковый номер даты, начиная отсчет с начала года. Учесть, что год может быть високосным. 
# (Запрещено использовать встроенные в ruby методы для этого вроде Date#yday или Date#leap?) 
# Алгоритм опредления високосного года: docs.microsoft.com

# Условие високосного года:
# Если год делится нацело на 4, но не делится нацело на 100, это високосный год
# Если год делится как на 4, так и на 100, возможно, это не високосный год, должен еще и делиться на 400. Все что else будет невисокосным.

# ввод данных
puts "Enter date:"
date = gets.chomp.to_i
puts "Enter month:"
month = gets.chomp.to_i
puts "Enter year:"
year = gets.chomp.to_i

# переменные
m_hash = {} 				                            # хеш на весь год с номером месяца и колчиесвом дней в нем
months = %w(31 28 31 30 31 30 31 31 30 31 30 31)
days = [] 					                            # days - сумма дней месяцев стоящих перед введенным месяцем

# определяем високосный или нет
if (year % 4 == 0) && (year % 100 != 0)         # Если нацело делится на 4, но не на 100 
  months[1] = 29 																# добавляем один день к февралю  и 
  puts "Високосный, делится на 4, не делится на 100"
	elsif (year % 4 == 0) && (year % 100 == 0) && (year % 400 == 0) # Если нацело делится на 4, 100 и 400 
		months[1] = 29
		puts "Високосный, делится на 4, 100 и 400"
	else
		puts "Не високосный"
end

# вычисляем номер даты в году
months.each_with_index do |days, index|   # итерируем массив months
  m_hash[index + 1] = days.to_i             # в хеш m_hash закидываем месяца как значения, а их индексы станут номерами месяцев
end

# считаем дни
while month > 1                           # до тех пор пока значение от изначально введенного месяца больше 1
	month -= 1                                # отнимаем от значения по единице за цикл, таким образом получается итерация пар влево
	days.push(m_hash.dig(month))              # находим в хеше m_hash методом dig (метод dig возвращает значени по ключу) получившиеся при отнимании ключи и складываем их значения в массив days
end

days.unshift(date)                        # добавляем методом unshift введенную дату в начало массива
p days.sum                                 # получаем и выводим сумму элементов массива, которая является суммой значений всех предыдущих перед введенным месяцем днем, плюс текущая дата. Таким образом нашли порядковый номер введенной даты
